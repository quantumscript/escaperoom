/********************************************************************
Class: CS 344 - Operating Systems
Author: KC
Date: April 25 2018
Description: Paired with adventure.c to make a simple text adventure game
where a player explores rooms that are autogenerated in buildrooms.c and
contain a limited number of connections to other rooms. Once the player reaches
the final room the game is over.
Input: None
Output: Room files containing ROOM NAME, CONNECTION X..Y, ROOM TYPE. Files are
created before user command line input in adventure.c
**********************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/types.h>
#include <fcntl.h>

#define MAX_ROOMS 7
#define NUM_ROOMS 10
#define NUM_CXNS 6 // Maximum number of connections to other rooms

struct room {
	char* name;
	char* roomType;
	struct room* cxns[NUM_CXNS];
};

void chooseRooms(struct room* []);
int connectRooms(struct room* [], int, int);
int checkCxns(struct room* []);
int connectRooms(struct room* [], int, int);
void makeGraph(struct room* []);
void writeFiles(int, struct room*);
void makeFiles(struct room* []);


/*******************************************************/
int main() {
	// Create an array of pointers to 7 room structs and create each room on the heap
	struct room* rooms[MAX_ROOMS];
	int i;
	for (i=0; i<MAX_ROOMS; i++) {
		rooms[i] = malloc(sizeof(struct room));

		// Initialize all struct cxn pointers to NULL
		int j;
		for (j=0; j<NUM_CXNS; j++) {
			rooms[i]->cxns[j] = NULL;
		}
	}

	// Initialize names and roomTypes
	srand(time(NULL));
	chooseRooms(rooms);

	// Make graph of connections btwn rooms
	makeGraph(rooms);

	// Make directory and files
	makeFiles(rooms);

	// Free malloc memory
	for (i=0; i<MAX_ROOMS; i++) {
		free(rooms[i]);
	}

	return 0;
}


/*******************************************************/
// Choose MAX_ROOMS of NUM_ROOMS hard coded rooms
void chooseRooms(struct room* roomsIn[]) {
	char* roomNames[NUM_ROOMS];
	roomNames[0] = "cave";
	roomNames[1] = "dungeon";
	roomNames[2] = "cavern";
	roomNames[3] = "loft";
	roomNames[4] = "tower";
	roomNames[5] = "foyer";
	roomNames[6] = "sunroom";
	roomNames[7] = "lab";
	roomNames[8] = "pantry";
	roomNames[9] = "shed";

	// Randomizer sets names in rooms. Starts at iteger from 0 to NUM_ROOMS, is incremented and loops back to 0 for MAX_ROOMS iterations
	int a = rand() % NUM_ROOMS;
	int b;

	int i;
	for (i=0; i<MAX_ROOMS; i++) {
		// Assign rooms based on randomizer
		b = (i + a) % NUM_ROOMS;
		roomsIn[i]->name = roomNames[b];

		// Set roomType
		if (i == 0) {
			roomsIn[i]->roomType = "START_ROOM"; }
		else if (i == MAX_ROOMS - 1) {
			roomsIn[i]->roomType = "END_ROOM"; }
		else {
			roomsIn[i]->roomType = "MID_ROOM"; }
//		printf("%s\n", roomsIn[i]->name);
	}
}

/*******************************************************/
// Check if all rooms have at least 3 connections or not
int checkCxns(struct room* roomIn[]) {
	int i;
	for (i=0; i<MAX_ROOMS; i++) {
		// If the third connection is not set up, return false
		if (roomIn[i]->cxns[2] == NULL) {
			return 0; }
	}
	return 1;
}

/*******************************************************/
// Connect rooms
int connectRooms(struct room* roomsIn[], int idxA, int idxB) {
	// Add room B to A and A to B if they're not already connected and if each has
	// less than 6 cxns. Increment counter for room A and return 1 if they're already connected
	int a = 0;
	while (a < NUM_CXNS && roomsIn[idxA]->cxns[a] != NULL) {
		// If the rooms are connected already, return 1
		if (roomsIn[idxA]->cxns[a] == roomsIn[idxB]) { return 1; }
		a++;
	}

	// Increment counter for room B
	int b = 0;
	while (b < NUM_CXNS && roomsIn[idxB]->cxns[b] != NULL) { b++; }

	// If both the counters for A and B are less than NUM_CXNS, connect them, return status 0
	if (a < NUM_CXNS && b < NUM_CXNS) {
		roomsIn[idxA]->cxns[a] = roomsIn[idxB];
		roomsIn[idxB]->cxns[b] = roomsIn[idxA];
		return 0;
	}

	// Connection maxed out, return status 2
	else { return 2; }
}

/*******************************************************/
// Generate connections btwn rooms in pairs until each room has at least 3 connections.
// Each room can have no more than 6 connections and each connection is bidirectional
void makeGraph(struct room* roomsIn[]) {
	// Get two indices (rooms), connect them
	int idxCur = 0;
	int interval;
	int a; int b;
	while ( checkCxns(roomsIn) == 0 ) {
		// Room names were randomized, so can use loop using random interval
		interval = rand() % MAX_ROOMS;
		a = idxCur;
		b = (idxCur + interval) % MAX_ROOMS;
		// If rooms a and b are not the same, try to connect them
		if ( a != b ) {
			connectRooms(roomsIn, a, b);
		}

		idxCur = (idxCur + 1) % MAX_ROOMS;
	}
}

/*******************************************************/
// Write to files
void writeFiles(int file_descIn, struct room* roomIn) {
	// Write room name
	char roomName[25] = "ROOM NAME: ";
	strcat(roomName, roomIn->name);
	strcat(roomName, "\n");
	write(file_descIn, roomName, strlen(roomName) * sizeof(char));

	// Write connections
	int i=0;
	while ( roomIn->cxns[i] != NULL && i<NUM_CXNS) {
		char connectionX[25] = "CONNECTION ";
		char integerX[4];
		sprintf(integerX, "%i: ", i);
		strcat(connectionX, integerX);
//		printf("line 192, cxn name: %s\n", roomIn->cxns[i]->name);
		strcat(connectionX, roomIn->cxns[i]->name);
		strcat(connectionX, "\n");
		write(file_descIn, connectionX, strlen(connectionX) * sizeof(char));
		i++;
	}

	// Add room type
	char rType[25] = "ROOM TYPE: ";
	strcat(rType, roomIn->roomType);
	strcat(rType, "\n");
	write(file_descIn, rType, strlen(rType) * sizeof(char));

	// Set file pointer back to beginning
	lseek(file_descIn, 0, SEEK_SET);
}

/*******************************************************/
// Create files
void makeFiles(struct room* roomsIn[]) {
	// Make dir "rooms_PID"
	char dir[25] = "rooms_";
	int pid = getpid();
//	printf("pid: %i\n", pid);
	char pidChar[6];
	sprintf(pidChar, "%i", pid);

	strcat(dir, pidChar);
	mkdir(dir, 0755);

	// Make 7 room files corresponding to their names
	char filepath[27];
	int i;
	for (i=0; i<MAX_ROOMS; i++) {
		memset(filepath, '\0', 27);
		strcpy(filepath, dir);
		strcat(filepath, "/");
		strcat(filepath, roomsIn[i]->name);
		int file_desc = open(filepath, O_RDWR | O_CREAT, 0600); // user has read and write permissions

		// Write to file and close file
		writeFiles(file_desc, roomsIn[i]);
		close(file_desc);
	}
}
